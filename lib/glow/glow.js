'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var source = "struct GlowUniforms {\r\n  uDistance: f32,\r\n  uStrength: vec2<f32>,\r\n  uColor: vec3<f32>,\r\n  uAlpha: f32,\r\n  uQuality: f32,\r\n  uKnockout: f32,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n  @builtin(position) position: vec4<f32>,\r\n  @location(0) uv : vec2<f32>\r\n) -> @location(0) vec4<f32> {\r\n  let quality = glowUniforms.uQuality;\r\n  let distance = glowUniforms.uDistance;\r\n\r\n  let dist: f32 = glowUniforms.uDistance;\r\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\r\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\r\n\r\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\r\n\r\n  var totalAlpha: f32 = 0.0;\r\n\r\n  var direction: vec2<f32>;\r\n  var displaced: vec2<f32>;\r\n  var curColor: vec4<f32>;\r\n\r\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\r\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\r\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\r\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\r\n      curColor = textureSample(uTexture, uSampler, displaced);\r\n      totalAlpha += (dist - curDistance) * curColor.a;\r\n    }\r\n  }\r\n    \r\n  curColor = textureSample(uTexture, uSampler, uv);\r\n\r\n  let glowColorRGB = glowUniforms.uColor;\r\n  let glowAlpha = glowUniforms.uAlpha;\r\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\r\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\r\n  let innerStrength = glowUniforms.uStrength[0];\r\n  let outerStrength = glowUniforms.uStrength[1];\r\n\r\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\r\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\r\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\r\n  \r\n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\r\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\r\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\r\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\r\n  \r\n  if (knockout) {\r\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\r\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\r\n  }\r\n  else {\r\n    return innerColor + outerGlowColor;\r\n  }\r\n}\r\n\r\nconst PI: f32 = 3.14159265358979323846264;";

exports["default"] = source;
//# sourceMappingURL=glow.js.map
