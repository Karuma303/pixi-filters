var sourcePerlin = "// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\r\n\r\nfn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>\r\n{\r\n  return x - y * floor(x/y);\r\n}\r\nfn mod289Vec3(x: vec3<f32>) -> vec3<f32>\r\n{\r\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32>\r\n{\r\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\nfn permute4(x: vec4<f32>) -> vec4<f32>\r\n{\r\n    return mod289Vec4(((x * 34.0) + 1.0) * x);\r\n}\r\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>\r\n{\r\n    return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\nfn fade3(t: vec3<f32>) -> vec3<f32>\r\n{\r\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\r\n}\r\nfn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\r\n\r\nfn perlinNoise2(P: vec2<f32>) -> f32 {\r\n  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);\r\n  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);\r\n  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation\r\n  let ix = Pi.xzxz;\r\n  let iy = Pi.yyww;\r\n  let fx = Pf.xzxz;\r\n  let fy = Pf.yyww;\r\n  let i = permute4(permute4(ix) + iy);\r\n  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\r\n  let gy = abs(gx) - 0.5;\r\n  let tx = floor(gx + 0.5);\r\n  gx = gx - tx;\r\n  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);\r\n  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);\r\n  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);\r\n  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);\r\n  let norm = 1.79284291400159 - 0.85373472095314 *\r\n      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\r\n  g00 = g00 * norm.x;\r\n  g01 = g01 * norm.y;\r\n  g10 = g10 * norm.z;\r\n  g11 = g11 * norm.w;\r\n  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));\r\n  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));\r\n  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));\r\n  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));\r\n  let fade_xy = fade2(Pf.xy);\r\n  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));\r\n  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\r\n  return 2.3 * n_xy;\r\n}\r\n\r\n// Classic Perlin noise, periodic variant\r\nfn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32\r\n{\r\n    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period\r\n    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period\r\n    Pi0 = mod289Vec3(Pi0);\r\n    Pi1 = mod289Vec3(Pi1);\r\n    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation\r\n    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0\r\n    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);\r\n    let iz0: vec4<f32> = Pi0.zzzz;\r\n    let iz1: vec4<f32> = Pi1.zzzz;\r\n    let ixy: vec4<f32> = permute4(permute4(ix) + iy);\r\n    let ixy0: vec4<f32> = permute4(ixy + iz0);\r\n    let ixy1: vec4<f32> = permute4(ixy + iz1);\r\n    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);\r\n    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n    gx0 = fract(gx0);\r\n    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\r\n    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));\r\n    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);\r\n    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);\r\n    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);\r\n    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n    gx1 = fract(gx1);\r\n    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\r\n    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));\r\n    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);\r\n    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);\r\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\r\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\r\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\r\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\r\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\r\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\r\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\r\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\r\n    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 *= norm0.x;\r\n    g010 *= norm0.y;\r\n    g100 *= norm0.z;\r\n    g110 *= norm0.w;\r\n    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 *= norm1.x;\r\n    g011 *= norm1.y;\r\n    g101 *= norm1.z;\r\n    g111 *= norm1.w;\r\n    let n000: f32 = dot(g000, Pf0);\r\n    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\r\n    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\r\n    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\r\n    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\r\n    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\r\n    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\r\n    let n111: f32 = dot(g111, Pf1);\r\n    let fade_xyz: vec3<f32> = fade3(Pf0);\r\n    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);\r\n    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 2.2 * n_xyz;\r\n}\r\nfn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32\r\n{\r\n    var sum: f32 = 0.0;\r\n    var sc: f32 = 1.0;\r\n    var totalgain: f32 = 1.0;\r\n    for (var i = 0.0; i < 6.0; i += 1)\r\n    {\r\n        sum += totalgain * perlinNoise3(P * sc, rep);\r\n        sc *= lacunarity;\r\n        totalgain *= gain;\r\n    }\r\n    return abs(sum);\r\n}";

export { sourcePerlin as default };
//# sourceMappingURL=perlin.mjs.map
