'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var source = "struct ZoomBlurUniforms {\r\n    uStrength:f32,\r\n    uCenter:vec2<f32>,\r\n    uRadii:vec2<f32>,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) uv : vec2<f32>\r\n) -> @location(0) vec4<f32> {\r\n  let uStrength = zoomBlurUniforms.uStrength;\r\n  let uCenter = zoomBlurUniforms.uCenter;\r\n  let uRadii = zoomBlurUniforms.uRadii;\r\n\r\n  let minGradient: f32 = uRadii[0] * 0.3;\r\n  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;\r\n\r\n  let gradient: f32 = uRadii[1] * 0.3;\r\n  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;\r\n\r\n  let MAX_KERNEL_SIZE: f32 = ${MAX_KERNEL_SIZE};\r\n\r\n  var countLimit: f32 = MAX_KERNEL_SIZE;\r\n\r\n  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);\r\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));\r\n\r\n  var strength: f32 = uStrength;\r\n\r\n  var delta: f32 = 0.0;\r\n  var gap: f32;\r\n\r\n  if (dist < innerRadius) {\r\n      delta = innerRadius - dist;\r\n      gap = minGradient;\r\n  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\r\n      delta = dist - radius;\r\n      gap = gradient;\r\n  }\r\n\r\n  var returnColorOnly: bool = false;\r\n\r\n  if (delta > 0.0) {\r\n    let normalCount: f32 = gap / gfu.uInputSize.x;\r\n    delta = (normalCount - delta) / normalCount;\r\n    countLimit *= delta;\r\n    strength *= delta;\r\n    \r\n    if (countLimit < 1.0)\r\n    {\r\n      returnColorOnly = true;;\r\n    }\r\n  }\r\n\r\n  // randomize the lookup values to hide the fixed number of samples\r\n  let offset: f32 = rand(uv, 0.0);\r\n\r\n  var total: f32 = 0.0;\r\n  var color: vec4<f32> = vec4<f32>(0.);\r\n\r\n  dir *= strength;\r\n\r\n  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {\r\n    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;\r\n    let weight: f32 = 4.0 * (percent - percent * percent);\r\n    let p: vec2<f32> = uv + dir * percent;\r\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);\r\n    \r\n    if (t < countLimit)\r\n    {\r\n      color += sample * weight;\r\n      total += weight;\r\n    }\r\n  }\r\n\r\n  color /= total;\r\n\r\n  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);\r\n}\r\n\r\nfn modulo(x: f32, y: f32) -> f32\r\n{\r\n  return x - y * floor(x/y);\r\n}\r\n\r\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nfn rand(co: vec2<f32>, seed: f32) -> f32\r\n{\r\n  let a: f32 = 12.9898;\r\n  let b: f32 = 78.233;\r\n  let c: f32 = 43758.5453;\r\n  let dt: f32 = dot(co + seed, vec2<f32>(a, b));\r\n  let sn: f32 = modulo(dt, 3.14159);\r\n  return fract(sin(sn) * c + seed);\r\n}";

exports["default"] = source;
//# sourceMappingURL=zoom-blur.js.map
