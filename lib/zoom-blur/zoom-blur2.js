'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fragment = "precision highp float;\r\nin vec2 vTextureCoord;\r\nout vec4 finalColor;\r\n\r\nuniform sampler2D uTexture;\r\nuniform float uStrength;\r\nuniform vec2 uCenter;\r\nuniform vec2 uRadii;\r\n\r\nuniform vec4 uInputSize;\r\n\r\nconst float MAX_KERNEL_SIZE = ${MAX_KERNEL_SIZE};\r\n\r\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nhighp float rand(vec2 co, float seed) {\r\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\r\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\r\n    return fract(sin(sn) * c + seed);\r\n}\r\n\r\nvoid main() {\r\n    float minGradient = uRadii[0] * 0.3;\r\n    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;\r\n\r\n    float gradient = uRadii[1] * 0.3;\r\n    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;\r\n\r\n    float countLimit = MAX_KERNEL_SIZE;\r\n\r\n    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);\r\n    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));\r\n\r\n    float strength = uStrength;\r\n\r\n    float delta = 0.0;\r\n    float gap;\r\n    if (dist < innerRadius) {\r\n        delta = innerRadius - dist;\r\n        gap = minGradient;\r\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\r\n        delta = dist - radius;\r\n        gap = gradient;\r\n    }\r\n\r\n    if (delta > 0.0) {\r\n        float normalCount = gap / uInputSize.x;\r\n        delta = (normalCount - delta) / normalCount;\r\n        countLimit *= delta;\r\n        strength *= delta;\r\n        if (countLimit < 1.0)\r\n        {\r\n            gl_FragColor = texture(uTexture, vTextureCoord);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // randomize the lookup values to hide the fixed number of samples\r\n    float offset = rand(vTextureCoord, 0.0);\r\n\r\n    float total = 0.0;\r\n    vec4 color = vec4(0.0);\r\n\r\n    dir *= strength;\r\n\r\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\r\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\r\n        float weight = 4.0 * (percent - percent * percent);\r\n        vec2 p = vTextureCoord + dir * percent;\r\n        vec4 sample = texture(uTexture, p);\r\n\r\n        // switch to pre-multiplied alpha to correctly blur transparent images\r\n        // sample.rgb *= sample.a;\r\n\r\n        color += sample * weight;\r\n        total += weight;\r\n\r\n        if (t > countLimit){\r\n            break;\r\n        }\r\n    }\r\n\r\n    color /= total;\r\n    // switch back from pre-multiplied alpha\r\n    // color.rgb /= color.a + 0.00001;\r\n\r\n    gl_FragColor = color;\r\n}\r\n";

exports["default"] = fragment;
//# sourceMappingURL=zoom-blur2.js.map
