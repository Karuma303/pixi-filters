var source = "struct CRTUniforms {\r\n    uLine: vec4<f32>,\r\n    uNoise: vec2<f32>,\r\n    uVignette: vec3<f32>,\r\n    uSeed: f32,\r\n    uTime: f32,\r\n    uDimensions: vec2<f32>,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n  @builtin(position) position: vec4<f32>,\r\n  @location(0) uv : vec2<f32>\r\n) -> @location(0) vec4<f32> {\r\n    \r\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\r\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;\r\n\r\n  let uNoise = crtUniforms.uNoise;\r\n\r\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\r\n  {\r\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\r\n  }\r\n\r\n  if (crtUniforms.uVignette[0] > 0.)\r\n  {\r\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\r\n  }\r\n\r\n  if (crtUniforms.uLine[1] > 0.0)\r\n  {\r\n    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  \r\n  }\r\n\r\n  return color;\r\n}\r\n\r\nconst SQRT_2: f32 = 1.414213;\r\n\r\nfn modulo(x: f32, y: f32) -> f32\r\n{\r\n  return x - y * floor(x/y);\r\n}\r\n\r\nfn rand(co: vec2<f32>) -> f32\r\n{\r\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\r\n}\r\n\r\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\r\n{\r\n  let uVignette = crtUniforms.uVignette;\r\n  let uDimensions = crtUniforms.uDimensions;\r\n  \r\n  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;\r\n  var dir: vec2<f32> = vec2<f32>(0.5) - coord;\r\n  dir.y *= uDimensions.y / uDimensions.x;\r\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\r\n  return darker + (1.0 - darker) * (1.0 - uVignette[1]);\r\n}\r\n\r\nfn noise(coord: vec2<f32>) -> f32\r\n{\r\n  let uNoise = crtUniforms.uNoise;\r\n  let uSeed = crtUniforms.uSeed;\r\n\r\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\r\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\r\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\r\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\r\n}\r\n\r\nfn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\r\n{\r\n  var color = co;\r\n\r\n  let uDimensions = crtUniforms.uDimensions;\r\n\r\n  let curvature: f32 = crtUniforms.uLine[0];\r\n  let lineWidth: f32 = crtUniforms.uLine[1];\r\n  let lineContrast: f32 = crtUniforms.uLine[2];\r\n  let verticalLine: f32 = crtUniforms.uLine[3];\r\n\r\n  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);\r\n\r\n  let _c: f32 = select(1., curvature, curvature > 0.);\r\n  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);\r\n  let uv: vec2<f32> = dir * k;\r\n  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;\r\n  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;\r\n  color *= j;\r\n\r\n  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);\r\n  color *= 0.99 + ceil(segment) * 0.015;\r\n\r\n  return color;\r\n}";

export { source as default };
//# sourceMappingURL=crt.mjs.map
