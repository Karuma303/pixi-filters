var fragment = "precision highp float;\r\nin vec2 vTextureCoord;\r\nin vec2 vFilterCoord;\r\nout vec4 finalColor;\r\n\r\nconst int TYPE_LINEAR = 0;\r\nconst int TYPE_RADIAL = 1;\r\nconst int TYPE_CONIC = 2;\r\nconst int MAX_STOPS = 32;\r\n\r\nuniform sampler2D uTexture;\r\nuniform vec4 uOptions;\r\nuniform vec2 uCounts;\r\nuniform vec3 uColors[MAX_STOPS];\r\nuniform vec4 uStops[MAX_STOPS];\r\n\r\nconst float PI = 3.1415926538;\r\nconst float PI_2 = PI*2.;\r\n\r\nstruct ColorStop {\r\n    float offset;\r\n    vec3 color;\r\n    float alpha;\r\n};\r\n\r\nmat2 rotate2d(float angle){\r\n    return mat2(cos(angle), -sin(angle),\r\n    sin(angle), cos(angle));\r\n}\r\n\r\nfloat projectLinearPosition(vec2 pos, float angle){\r\n    vec2 center = vec2(0.5);\r\n    vec2 result = pos - center;\r\n    result = rotate2d(angle) * result;\r\n    result = result + center;\r\n    return clamp(result.x, 0., 1.);\r\n}\r\n\r\nfloat projectRadialPosition(vec2 pos) {\r\n    float r = distance(pos, vec2(0.5));\r\n    return clamp(2.*r, 0., 1.);\r\n}\r\n\r\nfloat projectAnglePosition(vec2 pos, float angle) {\r\n    vec2 center = pos - vec2(0.5);\r\n    float polarAngle=atan(-center.y, center.x);\r\n    return mod(polarAngle + angle, PI_2) / PI_2;\r\n}\r\n\r\nfloat projectPosition(vec2 pos, int type, float angle) {\r\n    if (type == TYPE_LINEAR) {\r\n        return projectLinearPosition(pos, angle);\r\n    } else if (type == TYPE_RADIAL) {\r\n        return projectRadialPosition(pos);\r\n    } else if (type == TYPE_CONIC) {\r\n        return projectAnglePosition(pos, angle);\r\n    }\r\n\r\n    return pos.y;\r\n}\r\n\r\nvoid main(void) {\r\n    int uType = int(uOptions[0]);\r\n    float uAngle = uOptions[1];\r\n    float uAlpha = uOptions[2];\r\n    float uReplace = uOptions[3];\r\n\r\n    int uNumStops = int(uCounts[0]);\r\n    float uMaxColors = uCounts[1];\r\n\r\n    // current/original color\r\n    vec4 currentColor = texture(uTexture, vTextureCoord);\r\n\r\n    // skip calculations if gradient alpha is 0\r\n    if (0.0 == uAlpha) {\r\n        finalColor = currentColor;\r\n        return;\r\n    }\r\n\r\n    // project position\r\n    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));\r\n\r\n    // check gradient bounds\r\n    float offsetMin = uStops[0][0];\r\n    float offsetMax = 0.0;\r\n\r\n    int numStops = int(uNumStops);\r\n\r\n    for (int i = 0; i < MAX_STOPS; i++) {\r\n        if (i == numStops-1){ // last index\r\n            offsetMax = uStops[i][0];\r\n        }\r\n    }\r\n\r\n    if (y  < offsetMin || y > offsetMax) {\r\n        finalColor = currentColor;\r\n        return;\r\n    }\r\n\r\n    // limit colors\r\n    if (uMaxColors > 0.) {\r\n        float stepSize = 1./uMaxColors;\r\n        float stepNumber = float(floor(y/stepSize));\r\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\r\n    }\r\n\r\n    // find color stops\r\n    ColorStop from;\r\n    ColorStop to;\r\n\r\n    for (int i = 0; i < MAX_STOPS; i++) {\r\n        if (y >= uStops[i][0]) {\r\n            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);\r\n            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);\r\n        }\r\n\r\n        if (i == numStops-1){ // last index\r\n            break;\r\n        }\r\n    }\r\n\r\n    // mix colors from stops\r\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\r\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\r\n\r\n    float segmentHeight = to.offset - from.offset;\r\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\r\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\r\n\r\n    float gradientAlpha = uAlpha * currentColor.a;\r\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\r\n\r\n    if (uReplace < 0.5) {\r\n        // mix resulting color with current color\r\n        finalColor = gradientColor + currentColor*(1.-gradientColor.a);\r\n    } else {\r\n        // replace with gradient color\r\n        finalColor = gradientColor;\r\n    }\r\n}\r\n";

export { fragment as default };
//# sourceMappingURL=color-gradient.mjs.map
