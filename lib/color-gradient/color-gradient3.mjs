var source = "struct BaseUniforms {\r\n  uOptions: vec4<f32>,\r\n  uCounts: vec2<f32>,\r\n};\r\n\r\nstruct StopsUniforms {\r\n  uColors: array<vec3<f32>, MAX_STOPS>,\r\n  uStops: array<vec4<f32>, MAX_STOPS>,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\r\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\r\n\r\nstruct VSOutput {\r\n  @builtin(position) position: vec4<f32>,\r\n  @location(0) uv : vec2<f32>,\r\n  @location(1) coord : vec2<f32>\r\n};\r\n\r\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\r\n{\r\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\r\n\r\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\r\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\r\n\r\n    return vec4(position, 0.0, 1.0);\r\n}\r\n\r\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\r\n{\r\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\r\n}\r\n\r\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\r\n{\r\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\r\n}\r\n\r\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\r\n{\r\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \r\n}\r\n\r\nfn getSize() -> vec2<f32>\r\n{\r\n  return gfu.uGlobalFrame.zw;\r\n}\r\n  \r\n@vertex\r\nfn mainVertex(\r\n  @location(0) aPosition : vec2<f32>, \r\n) -> VSOutput {\r\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\r\n  return VSOutput(\r\n   filterVertexPosition(aPosition),\r\n   vTextureCoord,\r\n   filterCoord(vTextureCoord),\r\n  );\r\n}\r\n\r\nstruct ColorStop {\r\n  offset: f32,\r\n  color: vec3<f32>,\r\n  alpha: f32,\r\n};\r\n\r\nfn rotate2d(angle: f32) -> mat2x2<f32>{\r\n  return mat2x2(cos(angle), -sin(angle),\r\n  sin(angle), cos(angle));\r\n}\r\n\r\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\r\n  var center: vec2<f32> = vec2<f32>(0.5);\r\n  var result: vec2<f32> = pos - center;\r\n  result = rotate2d(angle) * result;\r\n  result = result + center;\r\n  return clamp(result.x, 0.0, 1.0);\r\n}\r\n\r\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\r\n  var r: f32 = distance(pos, vec2<f32>(0.5));\r\n  return clamp(2.0 * r, 0.0, 1.0);\r\n}\r\n\r\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\r\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\r\n  var polarAngle: f32 = atan2(-center.y, center.x);\r\n  return ((polarAngle + angle) % PI_2) / PI_2;\r\n}\r\n\r\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\r\n  if (gradientType == TYPE_LINEAR) {\r\n      return projectLinearPosition(pos, angle);\r\n  } else if (gradientType == TYPE_RADIAL) {\r\n      return projectRadialPosition(pos);\r\n  } else if (gradientType == TYPE_CONIC) {\r\n      return projectAnglePosition(pos, angle);\r\n  }\r\n\r\n  return pos.y;\r\n}\r\n\r\n@fragment\r\nfn mainFragment(\r\n  @builtin(position) position: vec4<f32>,\r\n  @location(0) uv : vec2<f32>,\r\n  @location(1) coord : vec2<f32>\r\n) -> @location(0) vec4<f32> {\r\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\r\n  let uAngle: f32 = baseUniforms.uOptions[1];\r\n  let uAlpha: f32 = baseUniforms.uOptions[2];\r\n  let uReplace: f32 = baseUniforms.uOptions[3];\r\n\r\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\r\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\r\n\r\n  // current/original color\r\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\r\n\r\n  // skip calculations if gradient alpha is 0\r\n  if (uAlpha == 0.0) { return currentColor; }\r\n\r\n  // project position\r\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\r\n\r\n  // check gradient bounds\r\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\r\n  var offsetMax: f32 = 0.0;\r\n\r\n  let numStops: i32 = uNumStops;\r\n\r\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\r\n      if (i == numStops - 1) { // last index\r\n          offsetMax = stopsUniforms.uStops[i][0];\r\n      }\r\n  }\r\n\r\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\r\n\r\n  // limit colors\r\n  if (uMaxColors > 0.0) {\r\n      var stepSize: f32 = 1.0 / uMaxColors;\r\n      var stepNumber: f32 = floor(y / stepSize);\r\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\r\n  }\r\n\r\n  // find color stops\r\n  var stopFrom: ColorStop;\r\n  var stopTo: ColorStop;\r\n\r\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\r\n      if (y >= stopsUniforms.uStops[i][0]) {\r\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\r\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\r\n      }\r\n\r\n      if (i == numStops - 1) { // last index\r\n          break;\r\n      }\r\n  }\r\n\r\n  // mix colors from stops\r\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\r\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\r\n\r\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\r\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\r\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\r\n\r\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\r\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\r\n\r\n  if (uReplace < 0.5) {\r\n      // mix resulting color with current color\r\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\r\n  } else {\r\n      // replace with gradient color\r\n      return gradientColor;\r\n  }\r\n}\r\n\r\nconst PI: f32 = 3.14159265358979323846264;\r\nconst PI_2: f32 = PI * 2.0;\r\n\r\nconst TYPE_LINEAR: i32 = 0;\r\nconst TYPE_RADIAL: i32 = 1;\r\nconst TYPE_CONIC: i32 = 2;\r\nconst MAX_STOPS: i32 = 32;";

export { source as default };
//# sourceMappingURL=color-gradient3.mjs.map
