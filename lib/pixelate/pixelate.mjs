var source = "struct PixelateUniforms {\r\n  uSize:vec2<f32>,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> pixelateUniforms : PixelateUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n  @location(0) uv: vec2<f32>,\r\n  @builtin(position) position: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  let pixelSize: vec2<f32> = pixelateUniforms.uSize;\r\n  let coord: vec2<f32> = mapCoord(uv);\r\n\r\n  var pixCoord: vec2<f32> = pixelate(coord, pixelSize);\r\n  pixCoord = unmapCoord(pixCoord);\r\n\r\n  return textureSample(uTexture, uSampler, pixCoord);\r\n}\r\n\r\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\r\n{\r\n  var mappedCoord: vec2<f32> = coord;\r\n  mappedCoord *= gfu.uInputSize.xy;\r\n  mappedCoord += gfu.uOutputFrame.xy;\r\n  return mappedCoord;\r\n}\r\n\r\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\r\n{\r\n  var mappedCoord: vec2<f32> = coord;\r\n  mappedCoord -= gfu.uOutputFrame.xy;\r\n  mappedCoord /= gfu.uInputSize.xy;\r\n  return mappedCoord;\r\n}\r\n\r\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\r\n{\r\n  return floor( coord / size ) * size;\r\n}\r\n\r\n";

export { source as default };
//# sourceMappingURL=pixelate.mjs.map
