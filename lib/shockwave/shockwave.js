'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var source = "\r\nstruct ShockWaveUniforms {\r\n    uTime: f32,\r\n    uOffset: vec2<f32>,\r\n    uSpeed: f32,\r\n    uWave: vec4<f32>,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n    uInputSize:vec4<f32>,\r\n    uInputPixel:vec4<f32>,\r\n    uInputClamp:vec4<f32>,\r\n    uOutputFrame:vec4<f32>,\r\n    uGlobalFrame:vec4<f32>,\r\n    uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) uv : vec2<f32>\r\n) -> @location(0) vec4<f32> {\r\n\r\n    let uTime = shockwaveUniforms.uTime;\r\n    let uOffset = shockwaveUniforms.uOffset;\r\n    let uSpeed = shockwaveUniforms.uSpeed;\r\n    let uAmplitude = shockwaveUniforms.uWave[0];\r\n    let uWavelength = shockwaveUniforms.uWave[1];\r\n    let uBrightness = shockwaveUniforms.uWave[2];\r\n    let uRadius = shockwaveUniforms.uWave[3];\r\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;\r\n    let maxRadius: f32 = uRadius / gfu.uInputSize.x;\r\n    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;\r\n    var fade: f32 = 1.0;\r\n    var returnColorOnly: bool = false;\r\n    \r\n    if (maxRadius > 0.0) {\r\n        if (currentRadius > maxRadius) {\r\n            returnColorOnly = true;\r\n        }\r\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\r\n    }\r\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);\r\n    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;\r\n\r\n    let dist:f32 = length(dir);\r\n\r\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\r\n        returnColorOnly = true;\r\n    }\r\n\r\n    let diffUV: vec2<f32> = normalize(dir);\r\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\r\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\r\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\r\n    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;\r\n    // Do clamp :\r\n    let coord: vec2<f32> = uv + offset;\r\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\r\n\r\n    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\r\n    \r\n    if (boolVec2(coord, clampedCoord)) \r\n    {\r\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\r\n    }\r\n    // No clamp :\r\n    var finalColor = clampedColor;\r\n\r\n    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);\r\n}\r\n\r\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\r\n{\r\n    if (x.x == y.x && x.y == y.y)\r\n    {\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nconst PI: f32 = 3.14159265358979323846264;\r\n";

exports["default"] = source;
//# sourceMappingURL=shockwave.js.map
