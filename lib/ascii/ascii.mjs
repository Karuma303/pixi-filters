var source = "struct AsciiUniforms {\r\n    uSize: f32,\r\n    uColor: vec3<f32>,\r\n    uReplaceColor: f32,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n    uInputSize:vec4<f32>,\r\n    uInputPixel:vec4<f32>,\r\n    uInputClamp:vec4<f32>,\r\n    uOutputFrame:vec4<f32>,\r\n    uGlobalFrame:vec4<f32>,\r\n    uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n    @location(0) uv: vec2<f32>,\r\n    @builtin(position) position: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n    let pixelSize: f32 = asciiUniforms.uSize;\r\n    let coord: vec2<f32> = mapCoord(uv);\r\n\r\n    // get the rounded color..\r\n    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));\r\n    pixCoord = unmapCoord(pixCoord);\r\n\r\n    var color = textureSample(uTexture, uSampler, pixCoord);\r\n\r\n    // determine the character to use\r\n    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\r\n    \r\n    var n: f32 = 65536.0; // .\r\n    if (gray > 0.2) {\r\n        n = 65600.0;    // :\r\n    }\r\n    if (gray > 0.3) {\r\n        n = 332772.0;   // *\r\n    }\r\n    if (gray > 0.4) {\r\n        n = 15255086.0; // o\r\n    }\r\n    if (gray > 0.5) {\r\n        n = 23385164.0; // &\r\n    }\r\n    if (gray > 0.6) {\r\n        n = 15252014.0; // 8\r\n    }\r\n    if (gray > 0.7) {\r\n        n = 13199452.0; // @\r\n    }\r\n    if (gray > 0.8) {\r\n        n = 11512810.0; // #\r\n    }\r\n\r\n    // get the mod..\r\n    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));\r\n    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);\r\n}\r\n\r\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\r\n{\r\n    return floor( coord / size ) * size;\r\n}\r\n\r\nfn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\r\n{\r\n    return moduloVec2( coord , size) / size;\r\n}\r\n\r\nfn character(n: f32, p: vec2<f32>) -> f32\r\n{\r\n    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);\r\n\r\n    if (clamp(q.x, 0.0, 4.0) == q.x)\r\n    {\r\n        if (clamp(q.y, 0.0, 4.0) == q.y)\r\n        {\r\n        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)\r\n        {\r\n            return 1.0;\r\n        }\r\n        }\r\n    }\r\n\r\n    return 0.0;\r\n}\r\n\r\nfn modulo(x: f32, y: f32) -> f32\r\n{\r\n  return x - y * floor(x/y);\r\n}\r\n\r\nfn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>\r\n{\r\n  return x - y * floor(x/y);\r\n}\r\n\r\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\r\n{\r\n    var mappedCoord: vec2<f32> = coord;\r\n    mappedCoord *= gfu.uInputSize.xy;\r\n    mappedCoord += gfu.uOutputFrame.xy;\r\n    return mappedCoord;\r\n}\r\n\r\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\r\n{\r\n    var mappedCoord: vec2<f32> = coord;\r\n    mappedCoord -= gfu.uOutputFrame.xy;\r\n    mappedCoord /= gfu.uInputSize.xy;\r\n    return mappedCoord;\r\n}";

export { source as default };
//# sourceMappingURL=ascii.mjs.map
