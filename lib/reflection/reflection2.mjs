var source = "struct ReflectionUniforms {\r\n  uMirror: f32,\r\n  uBoundary: f32,\r\n  uAmplitude: vec2<f32>,\r\n  uWavelength: vec2<f32>,\r\n  uAlpha: vec2<f32>,\r\n  uTime: f32,\r\n  uDimensions: vec2<f32>,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n  @builtin(position) position: vec4<f32>,\r\n  @location(0) uv : vec2<f32>\r\n) -> @location(0) vec4<f32> {\r\n  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;\r\n  let uBoundary: f32 = reflectionUniforms.uBoundary;\r\n  let uMirror: bool = reflectionUniforms.uMirror > 0.5;\r\n  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;\r\n  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;\r\n  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;\r\n  let uTime: f32 = reflectionUniforms.uTime;\r\n\r\n  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;\r\n  let coord: vec2<f32> = pixelCoord /uDimensions;\r\n  var returnColorOnly: bool = false;\r\n\r\n  if (coord.y < uBoundary) {\r\n    returnColorOnly = true;\r\n  }\r\n\r\n  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\r\n  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;\r\n  let v: f32 = areaY + areaY - uv.y;\r\n  let y: f32 = select(uv.y, v, uMirror);\r\n\r\n  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;\r\n  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;\r\n  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);\r\n\r\n  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;\r\n  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);\r\n  \r\n  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;\r\n}\r\n\r\nfn rand(co: vec2<f32>) -> f32 \r\n{\r\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\r\n}";

export { source as default };
//# sourceMappingURL=reflection2.mjs.map
