var fragment = "precision highp float;\r\nin vec2 vTextureCoord;\r\nout vec4 finalColor;\r\n\r\nuniform sampler2D uTexture;\r\nuniform sampler2D uDisplacementMap;\r\nuniform float uSeed;\r\nuniform vec2 uDimensions;\r\nuniform float uAspect;\r\nuniform float uFillMode;\r\nuniform float uOffset;\r\nuniform float uDirection;\r\nuniform vec2 uRed;\r\nuniform vec2 uGreen;\r\nuniform vec2 uBlue;\r\n\r\nuniform vec4 uInputSize;\r\nuniform vec4 uInputClamp;\r\n\r\nconst int TRANSPARENT = 0;\r\nconst int ORIGINAL = 1;\r\nconst int LOOP = 2;\r\nconst int CLAMP = 3;\r\nconst int MIRROR = 4;\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;\r\n\r\n    if (coord.x > 1.0 || coord.y > 1.0) {\r\n        return;\r\n    }\r\n\r\n    float sinDir = sin(uDirection);\r\n    float cosDir = cos(uDirection);\r\n\r\n    float cx = coord.x - 0.5;\r\n    float cy = (coord.y - 0.5) * uAspect;\r\n    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\r\n\r\n    // displacementMap: repeat\r\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\r\n\r\n    // displacementMap: mirror\r\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\r\n\r\n    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));\r\n\r\n    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);\r\n\r\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);\r\n\r\n    int fillMode = int(uFillMode);\r\n\r\n    if (fillMode == CLAMP) {\r\n        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\r\n    } else {\r\n        if( coord.x > uInputClamp.z ) {\r\n            if (fillMode == TRANSPARENT) {\r\n                discard;\r\n            } else if (fillMode == LOOP) {\r\n                coord.x -= uInputClamp.z;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.x = uInputClamp.z * 2.0 - coord.x;\r\n            }\r\n        } else if( coord.x < uInputClamp.x ) {\r\n            if (fillMode == TRANSPARENT) {\r\n                discard;\r\n            } else if (fillMode == LOOP) {\r\n                coord.x += uInputClamp.z;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.x *= -uInputClamp.z;\r\n            }\r\n        }\r\n\r\n        if( coord.y > uInputClamp.w ) {\r\n            if (fillMode == TRANSPARENT) {\r\n                discard;\r\n            } else if (fillMode == LOOP) {\r\n                coord.y -= uInputClamp.w;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.y = uInputClamp.w * 2.0 - coord.y;\r\n            }\r\n        } else if( coord.y < uInputClamp.y ) {\r\n            if (fillMode == TRANSPARENT) {\r\n                discard;\r\n            } else if (fillMode == LOOP) {\r\n                coord.y += uInputClamp.w;\r\n            } else if (fillMode == MIRROR) {\r\n                coord.y *= -uInputClamp.w;\r\n            }\r\n        }\r\n    }\r\n\r\n    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;\r\n    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;\r\n    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;\r\n    finalColor.a = texture(uTexture, coord).a;\r\n}\r\n";

export { fragment as default };
//# sourceMappingURL=glitch2.mjs.map
