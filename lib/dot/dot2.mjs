var source = "struct DotUniforms {\r\n  uScale:f32,\r\n  uAngle:f32,\r\n  uGrayScale:f32,\r\n};\r\n\r\nstruct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \r\n@group(0) @binding(2) var uSampler: sampler;\r\n@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;\r\n\r\n@fragment\r\nfn mainFragment(\r\n  @location(0) uv: vec2<f32>,\r\n  @builtin(position) position: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\r\n  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));\r\n  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead \r\n  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);\r\n\r\n  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);\r\n}\r\n\r\nfn pattern(uv: vec2<f32>) -> f32\r\n{\r\n  let s: f32 = sin(dotUniforms.uAngle);\r\n  let c: f32 = cos(dotUniforms.uAngle);\r\n  \r\n  let tex: vec2<f32> = uv * gfu.uInputSize.xy;\r\n  \r\n  let p: vec2<f32> = vec2<f32>(\r\n      c * tex.x - s * tex.y,\r\n      s * tex.x + c * tex.y\r\n  ) * dotUniforms.uScale;\r\n\r\n  return (sin(p.x) * sin(p.y)) * 4.0;\r\n}";

export { source as default };
//# sourceMappingURL=dot2.mjs.map
